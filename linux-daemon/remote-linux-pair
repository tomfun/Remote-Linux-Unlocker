#!/usr/bin/env python3
import socket, sys, json, os


def is_json(myjson):
    try:
        json_object = json.loads(myjson)
    except ValueError:
        return False
    return True

def get_all_local_ips():
    """Get all local IP addresses including VPN and other interfaces."""
    ips = []
    
    # Method 1: Parse /proc/net/fib_trie for all local IPs
    try:
        with open("/proc/net/fib_trie") as fh:
            for line in fh:
                line = line.strip()
                if line.startswith('|--') and '/' in line:
                    ip_cidr = line.split('|--')[1].strip()
                    if '/' in ip_cidr:
                        ip = ip_cidr.split('/')[0]
                        # Skip multicast, broadcast, and localhost
                        if (not ip.startswith(('127.', '224.', '225.', '226.', '227.', '228.', '229.', '230.', '231.', '232.', '233.', '234.', '235.', '236.', '237.', '238.', '239.', '255.')) 
                            and ip not in ips and '.' in ip):
                            parts = ip.split('.')
                            if len(parts) == 4 and all(p.isdigit() and 0 <= int(p) <= 255 for p in parts):
                                ips.append(ip)
    except:
        pass
    
    # Method 2: Parse network interfaces from /proc/net/dev
    try:
        import subprocess
        result = subprocess.run(['ip', 'addr', 'show'], capture_output=True, text=True)
        for line in result.stdout.split('\n'):
            if 'inet ' in line and not 'inet 127.' in line:
                parts = line.strip().split()
                for i, part in enumerate(parts):
                    if part == 'inet' and i + 1 < len(parts):
                        ip_cidr = parts[i + 1]
                        ip = ip_cidr.split('/')[0]
                        if ip not in ips:
                            ips.append(ip)
    except:
        pass
    
    # Method 3: Get hostname addresses
    try:
        hostname = socket.gethostname()
        addr_info = socket.getaddrinfo(hostname, None)
        for info in addr_info:
            ip = info[4][0]
            if ip not in ips and not ip.startswith('127.'):
                ips.append(ip)
    except:
        pass
    
    # Method 4: Connect to remote to discover default route IP
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        if local_ip not in ips:
            ips.append(local_ip)
    except:
        pass
    
    return sorted(ips)


# Create a TCP/IP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)

# Bind the socket to the port
server_address = ('', 61598)

all_ips = get_all_local_ips()

print("You are about to pair a new device to this computer.\nIf you have not done so already, please open the Remote Linux Unlocker app. You can download it here: https://play.google.com/store/apps/details?id=com.maxchehab.remotelinuxunlocker\nWhen you are ready, please type one of the following IP addresses into the required field on your device.\n")

if all_ips:
    print("Available IP Addresses:")
    for ip in all_ips:
        print(f"  {ip}")
else:
    print("IP Address: Unable to determine local IP")
sock.bind(server_address)

# Listen for incoming connections
sock.listen(1)

while True:
    # Wait for a connection
    print('\nAwaiting your response...')
    connection, client_address = sock.accept()

    try:
        print('Connection received...')

        # Receive the data in small chunks and retransmit it
        while True:
            data = connection.recv(256).strip().decode('utf-8')
            print('Processing request...')
            if is_json(data):
                data = json.loads(data)
                if data["command"] == "pair" and len(data["key"]) == 64:
                    if os.path.exists(os.path.dirname(os.path.realpath(__file__)) + '/keys.db'):
                        append_write = 'a' # append if already exists
                    else:
                        append_write = 'w' # make a new file if not
                    with open(os.path.dirname(os.path.realpath(__file__)) + '/keys.db', append_write) as file:
                        file.write(data["key"] + "\n")
                    connection.sendall(b'{"status":"success"}')
                    print('Pairing was successful!')
                    sys.exit()

            else:
                print('Invalid request!', file=sys.stderr)
                sys.exit(1)
                break

    finally:
        # Clean up the connection
        connection.close()
